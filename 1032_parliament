/**
 * 给出一个数n，将其拆分为若干个互不相等的数字的和，要求这些数字的乘积最大。
 * 对于连乘式中，如果将一个乘数a更换为两个数字b×c（a=b+c且b>1,c>1）
 * 那么乘积只可能增大或不变，不会减小
 * 又因为各个数字不能相同，则果最理想的情况是从2开始的公差为1的等差数列
 * 但是有时是无法构成这样的等差数列的，因为构成到某一位时会出现构建下一位不够用的情况
 * 例如，n=6时，6=2+3+1。当我们要构成4的时候只剩下1了
 * 如果余数是1,那么我们必然要加到前面的某一个数字上，否则乘积无法增大
 * 如果是大于1的数，也必须加在前面的某些数字上
 * 对于一个余数，应该每次将余数中的一个1分配给数列中最小的数字
 * 这样才能使得乘积每次增大的幅度最大，因为增加量是所有除了最小乘数之外的数字的乘积
 * 但是这样做会造成数字重复，所以唯一可以避免数字重复的方法是将这些1从最大的数字开始依次向较小数分配
 * 让每个乘数增加1。但是这样仍然可能有剩余，但最多剩余1
 * 因为再多就足够构成下一个乘数的了
 * 同样为了避免重复，将这个1加在最大的乘数上。
 */
#include <iostream>
#include <cstdio>
using namespace std;
int n, ans[1000], total;
int main(){
    int i;
    bool first=true;
    cin>>n;
    i=2;
    total=0;
    while(total + i <=n){
        total += i;
        ans[i-2]=i;
        i++;
    }
    n -= total;
    i = i-3; //i回退至最后一个成功加入的位置
    total = i;
    while(i >= 0 && n > 0){
        n--;
        ans[i]++;
        i--;
    }
    if(n>0)
        ans[total]++;
    for(i=0; i<=total; i++){
        if(!first)
            cout<<" ";
        first=false;
        cout<<ans[i];
    }
    cout<<endl;
    return 0;
}
